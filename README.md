# LINUX 명령어 구현

## 1 cd 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/b3e32727-020c-4c61-9c23-b531ce6fcdc3)

cd 명령어는 change directory의 줄임말로 현재 작업 중인 디렉토리의 위치를 이동하는 명령어이다. 

./cd1로 실행하면 사용법을 알려주고 ./cd1 .(디렉토리)를 실행하면 현재 디렉토리로 이동하게 된다. 

## 2 pwd 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/b5eeeb02-18da-4aa1-aa59-df5eeb0ac65a)

pwd는 현재 디렉토리를 알려주는 명령어로 실행시 현재 디렉토리 경로가 출력된다.

## 3 ls 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/4a7aa65c-7cf4-47da-92bf-e2a810b24ed4)

ls는  디렉토리 내의 파일 및 디렉토리 정보를 출력하는 명령어다.

-opendir("."): 현재 디렉토리를 엽니다. 디렉토리를 열지 못한 경우 opendir 함수는 NULL을 반환하며, 이때는 에러 메시지를 출력하고 프로그램을 종료합니다.

-readdir(dir): 디렉토리 내의 다음 파일 또는 디렉토리 정보를 읽습니다. 읽은 정보는 struct dirent 구조체에 저장되며, 반복문을 통해 모든 파일과 디렉토리에 대해 순차적으로 출력합니다.

![image](https://github.com/wini66/linux_pj/assets/119557644/8c60f05b-dddb-4a77-9e87-9f9bc417e09b)

![image](https://github.com/wini66/linux_pj/assets/119557644/b3304233-9067-4250-b663-43576b233d04)

![image](https://github.com/wini66/linux_pj/assets/119557644/6e38b93b-bc58-47d2-abec-6dc293f7f2f9)

ls에서 -a -l -R 옵션을 추가로 구현했습니다.

entry->d_name:

struct dirent 구조체의 멤버인 d_name은 디렉토리 항목의 이름을 담고 있습니다.

-a 옵션:

entry->d_name[0] == '.' && entry->d_name[1] != '\0' 조건을 사용하여 숨김 파일 및 디렉토리를 출력합니다. 이름이 .으로 시작하고 길이가 1보다 큰 경우에 해당합니다.

-l 옵션:

struct stat 구조체를 사용하여 파일의 상세 정보를 얻습니다. stat 함수를 사용하여 파일의 정보를 가져오는데, 이를 통해 파일의 크기(file_stat.st_size)를 얻을 수 있습니다.

-R 옵션:

entry->d_type == DT_DIR && entry->d_name[0] != '.' 조건을 사용하여 디렉토리인 경우 재귀적으로 해당 디렉토리 내의 파일과 디렉토리를 출력합니다. opendir 함수를 사용하여 하위 디렉토리를 열고, 재귀적으로 list_files 함수를 호출하여 하위 디렉토리의 내용을 출력합니다.

snprintf 함수:

파일 경로를 생성하기 위해 사용되는 snprintf 함수는 형식화된 문자열을 생성하여 지정된 버퍼에 저장합니다. 버퍼 오버플로우를 방지하기 위해 버퍼의 크기를 지정하고, 필요한 경우 문자열이 잘리는 경고를 출력합니다.

closedir(dir):

opendir 함수로 열었던 디렉토리를 닫습니다. 이는 리소스 누수를 방지하기 위해 중요한 단계입니다.

## 4 mkdir 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/5ba945a4-25ee-4f2b-a2d9-89c5cd4e64e3)

mkdir을 통해 디렉토리를 생성할 수 있다. 

'const char *directory_name = argv[1];은 프로그램 실행 시 전달된 명령줄 인수(argument) 중에서 두 번째(argv[1]) 인수를 가리키는 포인터 변수 directory_name에 할당하는 구문입니다.

여기서 argv는 프로그램 실행 시 전달되는 명령줄 인수들을 담고 있는 문자열 배열입니다. 첫 번째 인수 argv[0]는 프로그램의 이름(실행 파일 이름)을 가리키고, 두 번째 인수 argv[1]부터는 사용자가 입력한 명령어 인수들이 차례로 저장됩니다.

따라서 const char *directory_name = argv[1];은 두 번째 인수인 디렉토리명을 가리키는 포인터 변수 directory_name에 할당하는 것입니다. 이렇게 함으로써 프로그램에서는 directory_name을 통해 사용자가 입력한 디렉토리명에 접근하고 활용할 수 있습니다.

## 5 rm 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/abfbb4f3-8b4c-47f6-bec9-c3368efa9450)

파일이나 디렉토리를 삭제하는 명령어이다.

각 파일에 대해 unlink() 함수를 호출하여 파일을 삭제한다.

## 6 cp 명령어 구현

![cp1](https://github.com/wini66/linux_pj/assets/119557644/3f3aedb2-557f-4e49-abf1-405e1ca30248)

cp는 파일을 복사하는 명령어이다. cat으로 실행해보면 정상적으로 복사되었음을 확인할 수 있다.

![image](https://github.com/wini66/linux_pj/assets/119557644/37186aff-93f9-4e42-bc08-14f04467b27d)

cp 옵션으로 -r, -i, -v를 구현하였다. -r 옵션은 디렉토리를 재귀적으로 복사, -i는 덮어쓸지 여부를 사용자에게 확인하고, -v는 출력결과를 보여준다.

argv는 프로그램에 전달된 인자들을 저장하는 문자열 배열입니다.

argc는 argv 배열의 크기로, 전달된 인자의 개수를 나타냅니다.

예를 들어, ./cp -r tea jyp 명령을 실행할 경우, argv[0]에는 프로그램 이름인 ./cp가 저장되고, argv[1]에는 옵션인 -r이 저장되며, argv[2]에는 소스 경로인 tea가 저장되고, argv[3]에는 대상 경로인 jyp가 저장됩니다.

opendir 함수는 디렉토리를 열고, readdir 함수는 디렉토리 내의 항목들을 읽습니다.

디렉토리를 열고 읽어서 파일과 디렉토리를 식별하고 처리할 수 있습니다.

파일 복사는 fopen, fread, fwrite 등의 파일 입출력 함수를 사용하여 수행합니다.

소스 파일을 읽어서 대상 파일에 쓰는 방식으로 복사가 이루어집니다.

## 7 cat 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/eea17418-b944-45be-a3f6-3271905927bb)

파일 내용을 출력하는 명령어다.

먼저, main 함수를 정의합니다. 이 함수는 프로그램의 진입점으로, 프로그램이 실행될 때 가장 먼저 호출되는 함수입니다.

argc와 argv 매개변수를 통해 프로그램 실행 시 전달된 명령행 인수를 받습니다. argc는 명령행 인수의 개수를 나타내는 정수이고, argv는 문자열 배열로 실제 명령행 인수의 값들을 포함합니다.

argc 값이 2 미만인 경우, 즉 파일명이 주어지지 않은 경우 사용법을 출력하고 프로그램을 종료합니다.

argv[1]을 통해 명령행 인수로 전달된 파일명을 가져옵니다.

fopen 함수를 사용하여 파일을 읽기 모드로 엽니다. 파일 열기에 실패한 경우, perror 함수를 사용하여 오류 메시지를 출력하고 프로그램을 종료합니다.

fgetc 함수를 사용하여 파일로부터 문자를 읽어옵니다. fgetc 함수는 파일에서 한 문자씩 읽어오며, 읽은 문자를 putchar 함수를 사용하여 터미널에 출력합니다. 파일의 끝에 도달할 때까지 이 과정을 반복합니다.

파일 읽기가 완료되면 파일을 닫습니다. fclose 함수를 사용하여 파일을 닫습니다.

return 0 문을 통해 프로그램을 정상적으로 종료합니다.

## 8 touch 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/782ea223-8726-491a-afc8-65efc7057786)

touch는 파일 생성 또는 수정 시간을 갱신하는 명령어이다.

위 코드는 파일을 생성하고 파일 디스크립터를 닫는 간단한 과정으로 touch 명령어의 주요 기능을 수행합니다. 실행 시 파일명이 주어지지 않은 경우에는 프로그램이 종료되고, 파일명이 주어진 경우 해당 파일을 생성하거나 수정하여 수정 시간을 갱신합니다.

## 9 echo 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/14c89eab-e412-4b52-8ac9-6af9e3d6c362)

echo는 텍스트를 출력하는 명령어이다.

argc와 argv는 main 함수의 인자로 전달되는 값입니다. argc는 전달된 인자의 개수를 나타내며, argv는 전달된 인자들의 문자열 배열입니다. argv[0]은 프로그램의 실행 경로를 나타내는 문자열이며, argv[1]부터 실제 전달된 인자들이 저장되어 있습니다.

for 루프를 사용하여 argv 배열을 인덱스 1부터 끝까지 순회합니다. i 변수는 인덱스를 나타냅니다.

각 인자인 argv[i]를 printf 함수를 사용하여 출력합니다.

if 문을 사용하여 현재 인자가 마지막 인자가 아닌 경우에만 공백 문자를 출력합니다.

마지막으로 printf 함수를 사용하여 새 줄을 출력합니다.

이렇게 구현된 코드를 실행하면 프로그램 실행 시 전달된 인자들이 공백으로 구분되어 출력됩니다.

## 10 grep 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/90844291-1d76-4946-ac99-93fb0c58de8a)

파일내에서 특정 문자열을 검색하는 명령어이다.

사용자는 검색어와 파일명을 프로그램에 인자로 전달합니다. 프로그램은 해당 파일을 열고, 파일의 각 줄을 읽어와서 검색어가 포함된 줄을 출력합니다.

argc와 argv: 프로그램을 실행할 때 전달되는 인자의 개수와 값에 접근하기 위해 사용합니다. argc는 인자의 개수를 나타내며, argv는 인자의 값을 저장한 배열입니다. 첫 번째 인자 argv[0]에는 프로그램의 실행 경로가 저장되어 있습니다.

파일 열기: fopen 함수를 사용하여 지정된 파일을 읽기 모드로 엽니다. 파일 열기에 실패하면 NULL이 반환되며, perror 함수를 사용하여 오류 메시지를 출력합니다.

파일 내용 검색: fgets 함수를 사용하여 파일에서 한 줄씩 읽어옵니다. 각 줄에서 strstr 함수를 사용하여 검색어가 포함되어 있는지 확인합니다. 검색어가 포함된 줄은 출력됩니다.

파일 닫기: fclose 함수를 사용하여 파일을 닫습니다. 파일 작업이 완료되면 항상 파일을 닫아야 합니다.

## 11 chmod 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/574dbb05-5af4-4923-ae4d-25f2aa5f490f)

파일 또는 디렉토리의 권한을 변경하는 명령어이다. 여기서 755는 파일의 권한을 표현하는 숫자로 '-rwxr-xr-x'같은 뜻이며 이는 소유자에게 읽기, 쓰기, 실행 권한이 있고, 그룹과 기타 사용자에게는 읽기와 실행 권한이 있는 것을 나타냅니다. 

사용자는 변경할 권한 모드와 대상 파일명을 프로그램에 인자로 전달합니다. 프로그램은 해당 파일의 권한을 설정합니다.

strtol 함수: 문자열을 숫자로 변환하는 함수입니다. mode 문자열을 8진수로 변환하여 권한 모드를 설정합니다.

chmod 함수: 파일의 권한을 설정하는 함수입니다. filename과 chmod_result 값을 전달하여 파일의 권한을 변경합니다. 변경에 실패하면 perror 함수를 사용하여 오류 메시지를 출력합니다.

## 12 clear 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/ac68d46f-b14a-4e06-87d3-aceedbada37c)

화면을 모두 지우는 명령어이다.

ANSI 이스케이프 시퀀스를 사용하여 터미널 화면을 지우는 기능을 수행합니다. printf 함수를 사용하여 \033[H\033[J를 출력함으로써 터미널 화면을 초기화합니다.

## 13 whoami 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/f49de339-c610-4ce8-bb76-39532b93effe)

현재 로그인한 사용자의 이름을 출력하는 명령어이다.

위의 코드는 getenv("USER") 함수를 사용하여 현재 사용자의 이름을 가져오는 기능을 구현한 것입니다.

char *username = getenv("USER");: getenv("USER") 함수를 사용하여 환경 변수에서 "USER" 값을 가져와 username 변수에 저장합니다. 이는 현재 사용자의 이름을 나타냅니다.

if (username != NULL) {: 가져온 사용자 이름이 NULL이 아닌 경우에만 아래의 코드 블록을 실행합니다. 이는 사용자 이름이 성공적으로 가져와졌는지 확인하는 용도입니다.

printf("Current user: %s\n", username);: 현재 사용자의 이름을 출력합니다. %s 형식 지정자를 사용하여 문자열을 출력하고, username 변수를 인자로 전달합니다.

else {: 가져온 사용자 이름이 NULL인 경우, 즉 환경 변수에서 사용자 이름을 가져오지 못한 경우에 아래의 코드 블록을 실행합니다.

perror("getenv");: getenv 함수에서 에러가 발생한 경우, perror 함수를 사용하여 에러 메시지를 출력합니다.

return 1;: 에러가 발생했으므로 프로그램을 종료하기 전에 1을 반환하여 오류 상태를 나타냅니다.

return 0;: 프로그램이 정상적으로 실행되었으므로 0을 반환하여 성공 상태를 나타냅니다.

## 14 wc 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/06d16c2d-19cc-4b6b-b441-77ece879eaa9)

파일 내의 단어,줄,문자 수 등을 계산하는 명령어이다.

getchar() 함수를 사용하여 문자를 하나씩 읽어오며, 각각의 조건에 따라 해당 값을 증가시키고, 최종 결과를 출력합니다. 프로그램은 사용자가 Ctrl+D를 누를 때까지 입력을 받습니다.

## 15 hostname 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/9b9b8a00-f0f7-424d-af5e-9fdbfed8f9c4)

현재 시스템의 호스트이름을 확인하는 명령어이다.

gethostname 함수: 이 함수는 호스트 이름을 가져오는 시스템 호출입니다. 호스트 이름을 저장하기 위해 hostname 배열을 사용하고, gethostname 함수를 호출하여 실제 호스트 이름을 가져옵니다. 성공적으로 호스트 이름을 가져오면 출력됩니다.

오류 처리: 만약 gethostname 함수가 실패하면 perror 함수를 사용하여 오류 메시지를 출력합니다. 이를 통해 오류가 발생한 원인을 파악할 수 있습니다. 오류가 발생하면 프로그램은 종료됩니다.


## 16 uname 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/f7ad6b7a-ecf6-4d60-805d-bc1b48cd05ba)

시스템 정보를 가져와서 출력하는 명령어이다.

struct utsname sys_info;: sys/utsname.h 헤더 파일에 정의된 struct utsname 구조체 변수 sys_info를 선언합니다. 이 구조체는 시스템 정보를 저장하는 멤버들로 구성되어 있습니다.

if (uname(&sys_info) == -1) {: uname 함수를 사용하여 시스템 정보를 가져오는데, 이때 &sys_info를 인자로 전달합니다. uname 함수는 성공적으로 실행되면 0을 반환하고, 실패하면 -1을 반환합니다. 따라서 반환값이 -1인 경우에만 아래의 코드 블록을 실행합니다.

perror("uname");: uname 함수에서 에러가 발생한 경우, perror 함수를 사용하여 에러 메시지를 출력합니다.

printf("System name: %s\n", sys_info.sysname);: sys_info 구조체의 sysname 멤버를 출력하여 시스템 이름을 표시합니다. printf 함수와 %s 형식 지정자를 사용하여 문자열을 출력하고, sys_info.sysname 변수를 인자로 전달합니다. 이와 같은 방식으로 다른 시스템 정보도 출력합니다.

return 0;: 프로그램이 정상적으로 실행되었으므로 0을 반환하여 성공 상태를 나타냅니다.

## 17 history 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/0a5915dd-85b3-495d-9ec7-afec10057760)

사용자가 이전에 입력한 명령어들의 기록을 보여주는 명령어다. 숫자 1은 실행한 명령어의 순서를 보여준다.

char* history[HISTORY_SIZE];: history는 입력된 명령어를 저장할 문자열 포인터 배열입니다. HISTORY_SIZE는 배열의 최대 크기를 나타내는 상수입니다.

printf("Enter a command: ");: 사용자에게 명령어를 입력하라는 안내 메시지를 출력합니다.

fgets(input, sizeof(input), stdin);: fgets 함수를 사용하여 사용자로부터 입력을 받습니다. input 배열에 최대 100자까지 입력된 문자열이 저장됩니다.

history[count] = strdup(input);: 입력된 명령어를 strdup 함수를 사용하여 동적으로 복제하여 history 배열에 저장합니다. 이를 통해 입력된 명령어가 메모리에 안전하게 보관됩니다.

count++;: 명령어 개수를 증가시킵니다.

printf("%d: %s", i+1, history[i]);: history 배열에 저장된 명령어를 인덱스와 함께 출력합니다. i+1은 인덱스를 1부터 시작하도록 보정하는 역할을 합니다.

free(history[i]);: history 배열에 동적으로 할당된 메모리를 해제합니다. 이를 통해 사용이 완료된 메모리를 반환합니다.

## 18 head 명령어 구현

![head1](https://github.com/wini66/linux_pj/assets/119557644/1efa8efd-3a47-4b92-9392-245fd79c80a8)

파일의 앞 부분을 일부 출력하는 명령어이다.

main 함수: 프로그램의 진입점입니다. 명령행 인수를 통해 파일 이름을 전달받습니다.

argc와 argv: argc는 명령행 인수의 개수를 나타내는 변수이고, argv는 인수를 저장하는 문자열 배열입니다. argc가 2보다 작을 경우 사용법을 출력하고 프로그램을 종료합니다.

파일 열기: fopen 함수를 사용하여 명령행 인수로 전달받은 파일을 읽기 모드로 엽니다. 파일이 존재하지 않거나 열 수 없는 경우 오류 메시지를 출력하고 프로그램을 종료합니다.

파일 내용 출력: fgets 함수를 사용하여 파일에서 한 줄씩 읽어옵니다. MAX_LINES로 지정한 줄 수까지 읽고 출력합니다.

파일 닫기: fclose 함수를 사용하여 파일을 닫아 리소스를 해제합니다.

## 19 ps 명령어 구현

![image](https://github.com/wini66/linux_pj/assets/119557644/025af5b0-ac80-4fe7-97a0-4f5726ca99d0)

ps는 현재 실행 중인 프로세스 목록을 출력하는 명령어이다. 

print_process_info 함수: 프로세스 ID(pid)를 인자로 받아 해당 프로세스의 정보를 출력합니다.

file_path 변수를 통해 /proc/<pid>/status 파일 경로를 생성합니다.
  
fopen 함수를 사용하여 파일을 엽니다. 만약 파일 열기에 실패하면 오류를 출력하고 함수를 종료합니다.
  
파일에서 한 줄씩 읽어오면서 "Name:" 또는 "State:"로 시작하는 줄을 찾아 출력합니다.
  
main 함수:

/proc 디렉토리를 엽니다. 만약 디렉토리 열기에 실패하면 오류를 출력하고 프로그램을 종료합니다.
  
readdir 함수를 사용하여 디렉토리 내의 파일을 읽어옵니다.
  
읽어온 파일이 디렉토리인 경우에만 처리를 진행합니다.
  
디렉토리 이름이 숫자로 이루어진 경우(프로세스 디렉토리) print_process_info 함수를 호출하여 해당 프로세스의 정보를 출력합니다.
  
## 20 rmdir 명령어 구현
  
![image](https://github.com/wini66/linux_pj/assets/119557644/558d136d-21f6-4830-8eb3-e2cb10d2db16)

rmdir은 빈 디렉토리를 제거하는 명령어이다.

-p 옵션을 추가하여 부모 디렉토리를 함께 제거하는 기능을 구현했습니다.
  
getopt 함수를 사용하여 명령줄 옵션을 파싱합니다. getopt 함수는 <unistd.h> 헤더 파일에 선언되어 있습니다.
  
while 루프를 사용하여 옵션을 처리합니다. -p 옵션이 주어진 경우 remove_parent 변수를 1로 설정합니다.
  
-p 옵션이 아닌 경우, ? 옵션이 주어진 경우(알 수 없는 옵션) 에러 메시지를 출력하고 프로그램을 종료합니다.
  
옵션을 제외한 나머지 인수의 개수가 1개가 아닌 경우, 즉 올바른 사용법이 아닌 경우 사용법을 출력하고 프로그램을 종료합니다.
  
## 21 tail 명령어 구현
  
![image](https://github.com/wini66/linux_pj/assets/119557644/3f67dcfb-bf21-4229-aa53-bfc3a8b455ff)

tail 명령어는 파일의 마지막 행을 기준으로 지정한 행까지의 파일 내용 일부를 출력합니다.
  
void tail(const char *filename, int num_lines) 함수:

파일 이름과 출력할 줄 수를 매개변수로 받습니다.
  
fopen 함수를 사용하여 파일을 엽니다.
  
파일의 크기를 구하기 위해 fseek 함수와 ftell 함수를 사용합니다.
  
파일 크기와 입력받은 줄 수를 비교하여 처리합니다.
 
int main(int argc, char *argv[]) 함수:

명령행 인자를 사용하여 파일 이름과 출력할 줄 수를 처리합니다.
  
정확히 3개의 명령행 인자가 입력되지 않은 경우, "Usage: ./tail <filename> <num_lines>"을 출력하고 종료합니다.
  
명령행 인자로 전달된 파일 이름과 줄 수를 tail 함수에 전달하여 파일의 마지막 줄 또는 지정된 줄 수를 출력합니다.
  
## 22 yes 명령어 구현
  
![image](https://github.com/wini66/linux_pj/assets/119557644/4ddebb8d-3a10-4195-b3c6-adffc13204a8)

yes는 ctrl+c를 입력받을때까지 반복해서 출력하는 명령어이다.
  
signal 함수를 사용하여 Ctrl+C 시그널(SIGINT)에 대한 핸들러를 등록합니다.
  
핸들러 함수 sigint_handler는 running 변수를 0으로 설정하여 무한 루프를 종료시키도록 합니다.
  
## 23 find 명령어 구현
  
![image](https://github.com/wini66/linux_pj/assets/119557644/f3e64e13-db7a-4599-95d2-c5028b196906)

특정 기준에 따라 파일을 검색하는 명령어이다.
  
find 함수: 주어진 디렉터리에서 검색어와 일치하는 파일/디렉터리를 찾는 재귀적인 함수입니다.
  
dir_path: 검색을 시작할 디렉터리 경로입니다.
  
search_term: 검색할 단어 또는 파일/디렉터리 이름입니다.
  
opendir: 주어진 디렉터리를 열어 디렉터리 핸들을 가져옵니다.
  
readdir: 디렉터리에서 파일 및 디렉터리 항목을 하나씩 읽어옵니다.
  
strcmp: 읽어온 항목과 검색어를 비교하여 일치 여부를 확인합니다.
  
printf: 일치하는 파일/디렉터리 경로를 출력합니다.
  
재귀적으로 하위 디렉터리에 대해 find 함수를 호출하여 검색을 진행합니다.

## 24 uniq 명령어 구현 
  
![image](https://github.com/wini66/linux_pj/assets/119557644/5d218843-64e1-4767-b9f4-7f8f5f100285)

중복된 행을 제거하는 명령어이다.
  
uniq 함수는 filename 매개변수로 전달된 파일의 내용을 읽어 중복된 행을 제거하고 유니크한 행을 출력합니다.
  
file 포인터를 사용하여 파일을 엽니다. 파일이 열리지 않는 경우 perror 함수를 사용하여 에러 메시지를 출력하고 함수를 종료합니다.
  
prev_line 변수는 이전 행을 저장하는 데 사용됩니다. 초기값은 빈 문자열로 설정됩니다.
  
파일에서 한 줄씩 읽으면서 현재 행과 이전 행이 같지 않은 경우에만 행을 출력합니다.
  
파일을 모두 읽고 출력이 완료되면 파일을 닫습니다.
  

  
  



  

  
  



























